<!DOCTYPE html><html lang="zh-CN"><head><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1"><meta name="author" content="NISAL"><link rel="alternative" href="/atom.xml" title="HIσ`∀´)σNISAL" type="application/atom+xml"><link rel="icon" href="/favicon.png"><title>JavaScript正则表达式学习 - HIσ`∀´)σNISAL</title><link rel="stylesheet" href="/css/main.css"><link rel="stylesheet" href="/js/fancybox/jquery.fancybox.min.css"><!--[if lt IE 9]><script>(function(a,b){a="abbr article aside audio bdi canvas data datalist details dialog figcaption figure footer header hgroup main mark meter nav output progress section summary template time video".split(" ");for(b=a.length-1;b>=0;b--)document.createElement(a[b])})()</script><![endif]--><script src="/js/jquery-3.1.1.min.js"></script><script src="/js/fancybox/jquery.fancybox.min.js"></script></head><body style="opacity:0"><header class="head"><h1 class="head-title u-fl"><a href="/">HIσ`∀´)σNISAL</a></h1><nav class="head-nav u-fr"><ul class="head-nav__list"><li class="head-nav__item"><a class="head-nav__link" href="/archives">カタログ/（目录）</a></li></ul></nav></header><main class="main"><article class="post"><header class="post__head"> <time class="post__time" datetime="2018-04-24T18:31:42.000Z">April 25, 2018</time><h1 class="post__title"><a href="/2018/04/25/JavaScript正则表达式学习/">JavaScript正则表达式学习</a></h1><div class="post__main echo"><p>搞了一段的时间的JS了 还没好好的弄过正则表达式</p>
<p>其实正则表达式内容并不多 也不难</p>
<hr>

<p></p><h1><strong>目录Menu</strong></h1><p></p>
<ul><br>     <li><a href="#zero" target="_self">引</a></li><br>     <li><a href="#one" target="_self">RegExp对象</a></li><br>     <li><a href="#two" target="_self">字符类</a></li><br>     <li><a href="#three" target="_self">范围类</a></li><br>     <li><a href="#four" target="_self">预定义类</a></li><br>     <li><a href="#five" target="_self">量词</a></li><br>     <li><a href="#sex" target="_self">贪婪模式和非贪婪模式</a></li><br>     <li><a href="#seven" target="_self">分组&amp;或</a></li><br>     <li><a href="#eight" target="_self">前瞻</a></li><br></ul>

<p><div id="zero" style="height: 60px;"></div></p>
<p></p><h1><strong>0.引</strong></h1><br>抛一下概念<p></p>
<p>正则表达式的的作用就是 <strong>按照某种 规则 去匹配符合条件的字符串</strong></p>
<p>正则表达式由两种基本的字符类型组成</p>
<p></p><p style="padding-left: 30px;">1.原义文本字符<br>2.元字符</p><br>那么原义字符就是代表字符本身的字符 比如我表达式为 a 那么匹配的就是a<p></p>
<p>元字符则是在正则表达式中有<strong>特殊含义</strong>的非字母字符<br><strong>* + ？ $ ^ . | / () {} [] 这些是元字符<br>\t \v \b \r \0 \f \cX也是元字符</strong></p>
<p><img src="/images/reg/1.png" alt=""></p>
<p>&nbsp;</p>
<p>另外为了学习和平时可视化可视化观察自己的正则表达式 可以在<strong><a href="https://regexper.com/" target="_blank" rel="noopener">https://regexper.com/</a></strong>进行预览</p>
<p><div id="one" style="height: 60px;"></div></p>
<p></p><h1><strong>1.RegExp对象</strong></h1><br>因为是学习JavaScript的正则表达式 所以要使用JS的RegExp对象<p></p>
<p>声明或者实例化一个RegExp对象很简单 有两种方式</p>
<p><ul><br>     <li><span style="color: #008000;">第一种方式</span></li><br></ul></p>
<pre class="lang:js decode:true">var reg = /\d/g</pre>
\d为正则表达式内容 使用 / /g包起来就实例化了一个正则表达式的对象
<ul>
     <li><span style="color: #008000;">第二种方式</span></li>
</ul>
<pre class="lang:default decode:true">var reg = new RegExp("//d", "g")</pre>
这个和上面一种方式实例化的<strong>结果一致</strong>

那么这个后面的g代表什么呢

【接下来所有演示都围绕<strong>replace</strong>方法】

来对比一下两个例子
<pre class="lang:js decode:true ">"He is my firend.".replace(/i/, "I");
//He Is my firend.

"He is my firend.".replace(/i/g, "I");
//He Is my fIrend.</pre>
这里的g代表<strong><span style="color: #008000;">global</span> 全局的意思</strong>

意思就是说 如果我是全局的 就进行全局的匹配 否则就只匹配第一个

当然除了g还有别的标识符
<div id="two" style="height: 60px;"></div>
<h1><strong>2.字符类</strong></h1>
字符类则为 [] 中括号包起来的字符

比如[nisal] 意思就是one of "nisal" 就是满足nisal的其中一个字符就是匹配成功
<pre class="lang:js decode:true">"n &amp; ni &amp; nisddd".replace(/[nisal]/g, "I");
//I &amp; II &amp; IIIddd</pre>
看上面的就可以知道  只要是nisal这其中一个字符就被匹配成功 替换成I

除此之外 还有<strong> ^  为字符类取反</strong> 它会创建一个反向类 例如: [^nisal] 就是匹配除了的字符
<pre class="lang:default decode:true ">"n &amp; ni &amp; nisddd".replace(/[^nisal]/g, "I");
//nIIIniIIInisIII</pre>
很好理解 除了nisal以外的字符都替换成了I
<div id="three" style="height: 60px;"></div>
<h1><strong>3.范围类</strong></h1>
假如说 我想匹配二十六个小写字母中的一个 那么我可以用字符类写成

<strong>[abcdefghijklmnopqrstuvwxyz]</strong>

很简单 但是这样写会显得表达式冗长杂乱 所以引入了范围类

范围类元字符为<strong>“-”</strong>

那么匹配二十六个小写字母就可以写成<strong>[a-z]</strong>

范围类所包含的是闭区间

那么<strong>匹配大小写字母</strong>就可以写成<span style="color: #008000;"><strong>[a-zA-Z]</strong> </span>连起来写就行

在字符类中使用范围类 在非范围类中使用"-"就是代表匹配字符"-"

比如<strong>匹配大小写字母和- </strong>就可以写成<span style="color: #008000;"><strong>[a-zA-Z-]</strong></span>
<pre class="lang:default decode:true ">"My birthday: 1997-01-25".replace(/[a-zA-Z-]/g, "?");
// ?? ????????: 1997?01?25</pre>
小例子
<div id="four" style="height: 60px;"></div>
<h1><strong>4.预定义类</strong></h1>
预定义类就是JavaScript提前帮我们准备好的类

预定义类大大提升了工作效率

预定义类中的元字符有 <strong>. \d \D \s \S \w \W</strong>

具体列了一张表

![](/images/reg/2.png)

这些是预定义类

当在匹配的时候 如果说我要匹配数字 则不用写[0-9] 只需要用\d代替即可
<div id="five" style="height: 60px;"></div>
<h1><strong>5.量词</strong></h1>
假如希望匹配一个连续出现100次数字的字符串

那么我们可以用预定义类这么写:

<strong>\d\d\d\d\d\d\d\d\d\d\d\d\d\d\d\d\d\d\d\d\d\d\d\d\d\d\d\d\d\d\d\d\d\d\d\d\d\d\d\d\d\d\d\d\d\d\d\d\d\d\d\d\d\d\d\d\d\d\d\d\d\d\d\d\d\d\d\d\d\d\d\d\d\d\d\d\d\d\d\d\d\d\d\d\d\d\d\d\d\d\d\d\d\d\d\d\d\d\d\d</strong>

是不是很简单 写100个\d不就好了嘛【麻烦】

为了解决这种问题 引入量词

那么两词的元字符有这些 <strong>? + * {n} {n,m} {n,}</strong>

具体是什么意思呢 也是有一张对照表

![](/images/reg/3.png)

量词就是来表示量词<strong>之前的字符或者组要进行几次匹配</strong>

有了量词 之前的就很简单了 先试一下这些量词
<pre class="lang:default decode:true">"One Once Oncce".replace(/Onc?e/g, "?");
// ? ? Oncce</pre>
看下这个 我要匹配Once 其中c要求出现1次或者0次  很好理解

那么我要求c出现次数为2 也就是我要匹配到"One Once Oncce"中的"Oncce"
<pre class="lang:default decode:true">"One Once Oncce".replace(/Onc{2}e/g, "?");
// One Once ?</pre>
通过{2}来表示匹配两次c就行

为了便于理解 上几个图

![](/images/reg/4.png)


&nbsp;

这个代表的就是 <strong>Onc{2}e </strong>这个表达式

![](/images/reg/5.png)


&nbsp;

这个表示<strong>Onc?e</strong>
<div id="sex" style="height: 60px;"></div>
<h1><strong>6.贪婪模式和非贪婪模式</strong></h1>
<strong>(1)贪婪模式</strong>

假如说我要在 <strong>12345678</strong>中 匹配 <strong>\d{3,6}</strong>

&nbsp;
<pre class="lang:default decode:true">"12345678".replace(/\d{3,6}/g, "?");
// ?78</pre>
在这个例子中 其实在匹配到123的时候已经满足了条件

但是他还是会向后匹配 直到到达量词的边界 简单的说 就是满足匹配的时候还会继续匹配 这个就是贪婪模式

<strong>(2)非贪婪模式</strong>

非贪婪模式则是一旦满足条件 就停止匹配 和贪婪模式相反
<pre class="lang:default decode:true">"12345678".replace(/\d{3,6}?/g, "?");
// ??78</pre>
要非贪婪模式 只要在量词之后加上一个 ? 即可

<strong>【元字符的含义不是唯一的 在不同场景下有不同的含义】</strong>

在上面这个例子中 数字会被匹配{3,6}次 但是因为在量词后面加了一个?

所以当匹配一旦成立 就会结束这次匹配 所以匹配到123后 将123变成? 再匹配456再将他变成?
<div id="seven" style="height: 60px;"></div>
<h1><strong>7.分组&amp;或</strong></h1>
<strong>(1)分组</strong>

如果我想匹配字符串Nisal连续出现三次的场景 那么一般新手会写成<strong>Nisal{3}【比如我】</strong>

这样是不可以的 因为量词作用在了字符"l"上 而不是整个Nisal

所以引入了分组 用 <strong>()</strong> 把Nisal括起来 把表达式写成 <strong>(Nisal){3}</strong>就好了

<strong>(2)或</strong>

或在正则表达式中是使用<strong> “ | ”</strong> 标识的 这有点像C++ 或者JS 等等很多语言的 " || "

例如 <strong>Nisal|well\sdone</strong>
<pre class="lang:js decode:true ">"Nisal well done. Well done!".replace(/Nisal|well done/g, "?");
// ? ?. Well done!</pre>
可以看到<strong>Nisal</strong> 和 <strong>well done</strong>都被匹配到了

那么还可以这样写 <strong>O(PP|\d)S</strong>
<pre class="lang:default decode:true ">"OPPS &amp; OS &amp; OPS!".replace(/O(PP|)S/g, "?");
// ? &amp; ? &amp; OPS!</pre>
这样 OPPS或者OS就都被匹配到了 这里用到了<strong>分组</strong>

<strong>(3)扩展</strong>

假如说 我想把我的生日<strong> 1997-01-25</strong> 通过正则表达式匹配成 <strong>01/25/1997</strong>

这样该怎么做

第一步 我们先把数字规则找到 匹配出来

年是4位数字 月和日都是2位数字

那么就可以通过他的规则来写表达式 得出为 <strong>\d{4}-\d{2}\d{2}</strong>

很简单 那么只要
<pre class="lang:js decode:true">"1997-01-25".replace(/\d{4}-\d{2}-\d{2}/g, "01/25/1997")</pre>
这样就可以完成

但是问题来了 如果说我不一定是这个日期 不一定每个人的生日都是这个 我怎么通过正则表达式获取年月日

<span style="color: #008000;"><strong>-只要对每个块进行分组 正则表达式就会提供里面的值</strong></span>

那么我要把年月日分组 稍微改一下之前的表达式

<strong>(\d{4})-(\d{2})-(\d{2})</strong>

这要这样分组 就可以通过<strong>$</strong>符号加上组的位置（通过1、2、3……标识）获取每个组的值
<pre class="lang:js decode:true ">"1997-01-25".replace(/(\d{4})-(\d{2})-(\d{2})/g, "$2/$3/$1");</pre>
只要这样写就好了

<strong>(4)忽略分组</strong>

那么我们有些特殊情况的时候 想<strong>忽略分组</strong>怎么办 比如为了用或匹配的时候

只要在分组内的最前面加上 <strong>?: </strong>就可以了 就可以忽略这次分组

举个例子 : <strong>(?:hello)*(world) </strong>

这个表达式有两个分组 看一下图形化的内容

![](/images/reg/6.png)

可以很明显的额看到第一个分组已经被忽略了
<div id="eight" style="height: 60px;"></div>
<h1><strong>8.前瞻</strong></h1>
<strong>什么是前瞻</strong>

正则表达式从文本头部向尾部开始解析 文本尾部方向 称为 “前”

前瞻就是在正则表达式匹配到规则的时候 向前检查是否符合断言 后顾/后瞻方向相反

但是JS并没有后顾的支持

符合和不符合特定断言称为肯定/正向匹配和否定/负向匹配

说得再明白简单点<span style="color: #008000;"><strong> 前瞻 这个正则表达式有两个条件 在匹配的时候看第一个条件 匹配到了再向后看满不满足第二个条件 第二个条件就是断言</strong></span>

<strong>exp(?=assert)</strong>

上面这个就是前瞻的语法

exp和assert都是规则 例如 n1*2
<pre class="lang:js decode:true ">"n1*2".replace(/\w(?=\d)/g, "x");
// x1*2
</pre>

<hr>

<p></p><h1><strong>9.补充</strong></h1><br>做个小补充】<p></p>
<p>^ 行开头</p>
<p>$行结尾</p>
<p>\b单词边界</p>
<p>&nbsp;</p>
<p>另外下面是学习之余的和正则多多少少有点关系的一些笔记 没有格式可言 不建议参考 只供自己查阅</p>
<p><pre class="lang:js decode:true ">// js对象属性<br>// global: 是否全文搜索 默认false<br>// ignore case: 是否大小写敏感 默认false<br>// multiline: 多行搜索 默认false<br>// lastIndex: 当前表达式匹配内容的最后一个字符的下一个位置【下次开始搜索的位置】<br>// soruse: 正则表达式的文本字符串</pre></p>
<p>// 方法<br>// RegExp.prototype.test(str) 用于测试字符串参数中是否存在匹配正则表达式模式的字符串</p>
<p>// RegExp.prototype.exec(str) 使用正则表达式模式对字符串执行搜索 并将更新全局RegExp对象的属性以反应匹配结果<br>// 如果没有匹配到文本则返回null,否则返回一个结果数组【返回index和匹配到的内容和字内容】<br>// 非全局下 lastIndex属性不生效 只找第一个匹配结果</p>
<p>// 字符串对象方法<br>// String.protatype.search(reg|str) 用于检索字符串中指定的子字符串 或检索与正则表达式相匹配的子字符串<br>//  检索成功返回第一个匹配到的结果位置index 否则返回-1（不支持全局匹配 只能找第一个）</p>
<p>// String.protptype.match(reg|str) 检索字符串 找到一个或多个与regexp匹配的文本<br>// 非全局调用<br>// 即regexp没有标志g 就只在字符串中执行一次匹配 如果没有匹配成功 返回null 否则返回一个数组 其中存放了它找到的匹配文本有关的信息<br>// 返回的数组的第一个元素存放的是匹配文本 其余的元素存放的是与正则表达式的子表达式匹配的文本<br>// 还包含了两个额外的属性 index 生命匹配文本的起始字符在字符串的位置  input 对stringObject的引用<br>// 全局调用<br>// 进行全局探索 找到字符串中的所有匹配子字符串 没有找到返回null 找到了一个或者多个则返回一个数组 数组中存放的是字符串中所有的匹配子串 也没有index和input属性</p>
<p>// String.prototype.split(reg|str)<br>// “a,b,c,d”.split(“,”); [“a”, “b”, “c”, “d”]<br>// 也可以使用正则表达式<br>// “n1i2s3a4l”.split(/\d/); [“a”, “b”, “c”, “d”]</p>
<p>// String.prototype.replace(str, replaceStr);<br>// String.prototype.replace(reg, replaceStr);<br>// String.prototype.replace(reg, function);<br>// 其中第三种的函数参数会在每次匹配替换的时候调用 有四个参数<br>// 1.匹配字符串【固定的参数 是匹配结果】 2.正则表达式的分组内容 没有分组则没有该参数 3.匹配向在字符串中的index 4.原字符串</p>
<p>/*<br>  无分组:<br>  “n1i2s3a4l” =&gt; “n2i3s4a5l”<br>  “n1i2s3a4l”.replace(/\d/g, function(match, index, origin){<br>    console.log(index);<br>    return parseInt(match) + 1;<br>  });</p>
<p>  有分组:<br>  “n1i2s3a4l” =&gt; “n23s34l”<br>  “n1i2s3a4l”.replace(/(\d)(\w)(\d)/g, function(match, group1, group2, group3, index, origin){<br>    console.log(match);<br>    return group1 + group3;<br>  });<br>*/<br>&nbsp;</p>
</div></header></article><!--div.comments#lv-container(data-id = theme.livere_id, data-uid = theme.livere_uid)//script.
  //(function(d, s) {var j, e = d.getElementsByTagName(s)[0];if (typeof LivereTower === 'function') { return; } j = d.createElement(s);j.src = 'https://cdn-city.livere.com/js/embed.dist.js';j.async = true;e.parentNode.insertBefore(j, e);})(document, 'script');--></main><footer class="foot"><div class="foot-copy">&copy; 2017-2018 NISAL</div></footer><script src="/js/scroller.js"></script><script src="/js/main.js"></script><script src="/live2dw/lib/L2Dwidget.min.js?0c58a1486de42ac6cc1c59c7d98ae887"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","model":{"jsonPath":"/live2dw/assets/01/assets/haru01.model.json"}});</script></body></html>