<!DOCTYPE html><html lang="zh-CN"><head><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1"><meta name="author" content="NISAL"><link rel="alternative" href="/atom.xml" title="HIσ`∀´)σNISAL" type="application/atom+xml"><link rel="icon" href="/favicon.png"><title>对象序列化与其他方法 - HIσ`∀´)σNISAL</title><link rel="stylesheet" href="/css/main.css"><link rel="stylesheet" href="/js/fancybox/jquery.fancybox.min.css"><!--[if lt IE 9]><script>(function(a,b){a="abbr article aside audio bdi canvas data datalist details dialog figcaption figure footer header hgroup main mark meter nav output progress section summary template time video".split(" ");for(b=a.length-1;b>=0;b--)document.createElement(a[b])})()</script><![endif]--><script src="/js/jquery-3.1.1.min.js"></script><script src="/js/fancybox/jquery.fancybox.min.js"></script></head><body style="opacity:0"><header class="head"><h1 class="head-title u-fl"><a href="/">HIσ`∀´)σNISAL</a></h1><nav class="head-nav u-fr"><ul class="head-nav__list"><li class="head-nav__item"><a class="head-nav__link" href="/archives">カタログ/（目录）</a></li></ul></nav></header><main class="main"><article class="post"><header class="post__head"> <time class="post__time" datetime="2018-04-24T18:38:58.000Z">April 25, 2018</time><h1 class="post__title"><a href="/2018/04/25/对象序列化与其他方法/">对象序列化与其他方法</a></h1><div class="post__main echo"><p>在和后端交互　或者做一些操作的时候　经常会用到JSON</p>
<p>JSON和JS的对象长得很想 毕竟JSON就是来自于JS对象的格式</p>
<p>所以JS提供了方法可以把JS对象直接转成JSON文本格式</p>
<pre class="lang:js decode:true ">var obj = {name: 'nisal', age: 18, isStudent: true, house:[1,2,3], nullVal: null}
alert(JSON.stringify(obj));
// 返回 {"name":"nisal","age":18,"isStudent":true,"house":[1,2,3],"nullVal":null}</pre>
这样就把一个JS的对象转成了JSON文本

是不是很简单。

但是！！没错 又是但是 这里面有几个坑点

<ul>
     <li>假如说 对象的某个属性值是undefined的话 那么经过序列化处理后 他不会出现在JSON文本中</li>
</ul>
<pre class="lang:js decode:true ">var obj = {name: undefined, age: 14};
alert(JSON.stringify(obj));</pre>
这样返回的是 <strong>{"age":14}</strong>
<ul>
     <li>如果属性值是<span style="color: #0000ff;"><strong>null、NaN、Infinit</strong></span>y的话 都会被转成null</li>
     <li>
<div>如果属性值是时间对象 那么会转成UTC时间</div>
<div></div></li>
</ul>
当然还可以自定义序列化的操作
<pre class="lang:js decode:true">var obj = {
  name: 'nisal',
  age: 14,
  total: {
    english: 20,
    math: 20,
    toJSON: function(){
      return this.english + this.math;
    }
  }
};
alert(JSON.stringify(obj));
// 返回 {"name":"nisal","age":14,"total":40}</pre>
使用<strong><span style="color: #0000ff;">toJSON</span></strong>就可以完成自定义对象的序列化 需要注意的是 只能通过<strong><span style="color: #0000ff;">toJSON</span></strong>方法来完成自定义 不然就不灵了

<hr>

上面这是对对象进行序列化的操作

既然可以序列化对象 那么也可以序列化JSON文本

使用JSON对象的parse属性
<pre class="lang:js decode:true">var json = '{"name":"nisal", "age":18, "hobby":"animate"}';
obj = JSON.parse(json);
alert(obj.hobby);

// 返回 animate
</pre>

<hr>

<p><strong><span style="color: #008000;">其他的一些对象方法</span></strong></p>
<div><br><ul><br>     <li>toString() 尝试把对象字符串化会调用的函数</li><br></ul><br><pre class="lang:js decode:true ">var obj = {x:1, y:2};<br>obj.toString(); 返回 [object Object]</pre><br>在上面的基础上 假如我们自己定义一个toString方法<br><pre class="lang:js decode:true">obj.toString = function(){return this.x + this.y};<br><br>“res:” + obj; // 返回 res:3</pre><br>因为res是字符串 左边是字符串 这里的加号就会做字符串拼接的操作 顺理成章得会跳动toString来吧obj转成字符类型 但是toString已经被我们自己重写了<br><br>同理<br><br>+obj 这个操作也会返回3<br><br></div><br><div><br><ul><br>     <li>valueOf 尝试吧对象转换为基本类型会调用的函数</li><br></ul><br>在上面代码的基础上 加上下面这些<br><pre class="lang:js decode:true">obj.valueOf = function(){return this.x + this.y + 100;};<br>+obj         //返回103 执行了valueOf<br>“res” + obj; //还是返回103</pre><br>这里重写了valueOf方法 再执行相同的操作 结果和上面不同<br><div><br><div>这是因为不论是一元的操作还是二元字符串拼接</div><br><div>当valueOf和toString同时存在的时候 在做具体操作时 会尝试把对象转换成基本类型 所以先回去尝试执行valueOf</div><br><div>如果valueOf返回的是基本类型的值的话 那就会返回valueOf的值作为结果</div><br><div><br><div><br><div>反之如果valueOf不存在或者返回的是一个对象 那么就会去执行toString</div><br></div><br></div><br></div><br></div></div></header></article><!--div.comments#lv-container(data-id = theme.livere_id, data-uid = theme.livere_uid)//script.
  //(function(d, s) {var j, e = d.getElementsByTagName(s)[0];if (typeof LivereTower === 'function') { return; } j = d.createElement(s);j.src = 'https://cdn-city.livere.com/js/embed.dist.js';j.async = true;e.parentNode.insertBefore(j, e);})(document, 'script');--></main><footer class="foot"><div class="foot-copy">&copy; 2017-2018 NISAL</div></footer><script src="/js/scroller.js"></script><script src="/js/main.js"></script></body></html>