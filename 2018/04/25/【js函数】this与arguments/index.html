<!DOCTYPE html><html lang="zh-CN"><head><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1"><meta name="author" content="NISAL"><link rel="alternative" href="/atom.xml" title="HIσ`∀´)σNISAL" type="application/atom+xml"><link rel="icon" href="/favicon.png"><title>【js函数】this与arguments - HIσ`∀´)σNISAL</title><link rel="stylesheet" href="/css/main.css"><link rel="stylesheet" href="/js/fancybox/jquery.fancybox.min.css"><!--[if lt IE 9]><script>(function(a,b){a="abbr article aside audio bdi canvas data datalist details dialog figcaption figure footer header hgroup main mark meter nav output progress section summary template time video".split(" ");for(b=a.length-1;b>=0;b--)document.createElement(a[b])})()</script><![endif]--><script src="/js/jquery-3.1.1.min.js"></script><script src="/js/fancybox/jquery.fancybox.min.js"></script></head><body style="opacity:0"><header class="head"><h1 class="head-title u-fl"><a href="/">HIσ`∀´)σNISAL</a></h1><nav class="head-nav u-fr"><ul class="head-nav__list"><li class="head-nav__item"><a class="head-nav__link" href="/archives">カタログ/（目录）</a></li></ul></nav></header><main class="main"><article class="post"><header class="post__head"> <time class="post__time" datetime="2018-04-24T18:39:54.000Z">April 25, 2018</time><h1 class="post__title"><a href="/2018/04/25/【js函数】this与arguments/">【js函数】this与arguments</a></h1><div class="post__main echo"><p>在this和arguments之前 先了解一下javascript的函数</p>
<p>js的函数创建方式一般有三种</p>
<ol><br>     <li><span style="color: #339966;"><strong>函数声明形式</strong></span></li><br>     <li><span style="color: #339966;"><strong>函数表达式</strong></span></li><br>     <li><span style="color: #339966;"><strong>函数构造器</strong></span></li><br></ol>

<hr>

<p></p><h1><span style="color: #ff0000;">函数声明</span></h1><br>函数声明的方式应该是最常用的方法之一<p></p>
<p><pre class="lang:js decode:true ">function add(a, b){return a + b;}</pre><br>采用function关键字 然后跟随一个函数名和参数 再加上一块函数体就是函数声明方式创建一个函数</p>
<a id="more"></a>
<p></p><h1><span style="color: #ff0000;">函数表达式</span></h1><br>函数表达式里面一般也有四种<p></p>
<p><ol><br>     <li></li></ol></p>
<p><pre class="lang:js decode:true ">var add = function(a, b){return a + b;}</pre><br>这也是常用的函数声明方式之一 用法和函数声明的用法没有任何区别<br>     <li></li></p>
<p><pre class="lang:js decode:true ">(function(){})();</pre><br>这是一种立即执行的匿名函数 也有叫自执行的匿名函数 在浏览器运行页面的时候 会立即执行这个函数<br>     <li></li></p>
<p><pre class="lang:js decode:true ">return function(){};</pre><br>还有就是将函数作为返回值的情况 这也是一种函数表达式 返回一个匿名函数<br>     <li></li></p>
<p><pre class="lang:js decode:true">var f = function func(a, b){return a + b;}</pre><br>这个比较特殊 这个叫命名函数表达式【NFE】<br><br>这种命名函数表达式有一点点特殊</p>
<p>在上面这个代码中 执行 f === func  在ie6 - ie8中会返回false 但是可以访问到f或者func</p>
<p>目前主流的浏览器中 执行f === func 会返回undefined 并且无法访问到func</p>
<p>另外一个区别就是 在使用命名函数表达式的时候在调用栈中会显示函数名 就是上面这个func</p>
<p>但是这个func呢 可以在这个命名函数表达式中<strong>递归操作的时候调用</strong></p>
<p>函数表达式和函数声明最大的区别就是</p>
<div><br><div><strong><span style="color: #ff00ff;">函数声明的函数会被前置 函数可以写在调用之后 而函数表达式只有变量的声明会被前置</span></strong></div><br><div>比如 var a = function(){} 这里的函数在不会被前置 但是使用var申明的变量a会被前置</div><br><div></div><br><div><br><h1><span style="color: #ff0000;">函数构造器</span></h1><br><pre class="lang:js decode:true ">var func = new Function(‘a’, ‘b’, ‘return a + b;’)</pre><br>函数构造器使用 new Function 来申明一个新的函数对象<br><br>另外 不加new 直接 var func = Function($#^&amp;%$*&amp;^%**$^%)  也是可以的 没有什么区别<br><br>其中他接受的参数中 最后一个参数表示函数体中的代码 其余的前面的参数都代表申明的函数的传入的形参<br><br>注意所有参数都是字符串 【所以这种方法也不太常用】<br><div><br><div>数构造器构造的函数 作用域和执行的一些方式 和一般的函数声明或者表达式申明的函数不太一样</div><br></div><br><div></div><br><div><br><pre class="lang:js decode:true">Function(‘var a = “hhhh”; console.log(a);’)();<br>console.log(a);<br>// hhhh<br>// undefined<br></pre><br>上面这个例子中 可以知道 当这个函数作为自执行函数的时候 其中的变量并不能全局访问 这是一点<br><br>另外一点就是 函数构造器构造的函数不能访问上一级函数的变量 但是可以访问全局变量<br><pre class="lang:default decode:true">var a = 1;<br>(function(){<br>  var lv = 2;<br>  Function(‘console.log(a, lv)’);<br>})();<br><br>// 1<br>// undefined</pre><br>很明显可以看到他只能访问全局变量 而不能访问上层函数的变量<br><br><hr><br><br><h1><strong><span style="color: #ff0000;">this</span></strong></h1><br>this是一个关键点 其实弄懂了并不是十分复杂 说白了他只是一个调用某个函数的时候 这个函数同时会被传入两个参数 一个是this 另一个是arguments 其中this就是指向的就是某个对象 需要搞懂的就是指向的是谁<br><ul><br>     <li><span style="color: #339966;">全局的this</span></li><br></ul><br>全局的this 指向就是在浏览器中的window<br><pre class="lang:js decode:true">this.document === document<br>this === wubdiw<br><br>// true<br>// true<br></pre><br><ul><br>     <li><span style="color: #339966;">一般函数的this</span></li><br></ul><br>一般在全局下的函数 他们的this会指向window<br><br>因为这个函数就是window对象下的一个方法<br><pre class="lang:js decode:true ">function foo(){return this;}<br>foo() === window<br><br>// true</pre><br>但是！<br><br>在严格模式下 一般函数的this就会指向undefined<br><pre class="lang:default decode:true ">function foo(){“use strict”; return this;}<br>foo() === undefined;<br><br>// true</pre><br><ul><br>     <li><span style="color: #339966;">作为对象方法的函数的this</span></li><br></ul><br><pre class="lang:js decode:true ">var obj = {<br>  name: ‘nisal’,<br>  getName: function(){return this.name;}<br>};<br>obj.getName();<br><br>// nisal</pre><br><div><br><div>只要将函数作为对象的方法来调用 this就会指向对象</div><br><div>所以同理 下面这个例子也会很好理解</div><br></div><br></div><br></div><br></div><br><div></div><br><div><br><pre class="lang:js decode:true ">var obj = {name: ‘nisal’};<br>function getName(){return this.name;}<br>obj.getName = getName;<br>obj.getName;<br><br>// nisal</pre><br><ul><br>     <li><span style="color: #339966;">对象原型链上的this</span></li><br></ul><br><pre class="lang:default decode:true">var obj = {f: function(){return this.a + this.b;}};<br>var o = Object.create(obj);<br>p.a = 1;<br>p.b = 2;<br>p.f();<br><br>// 3</pre><br>通过继承obj对象 并且继承以后的o对象有两个属性a和b 再调用obj原型上的方法f 是没有任何问题的<br><br>也就是说 <strong>通过原型链继承的对象 在原型上的this也可以指向当前对象</strong><br><ul><br>     <li><span style="color: #339966;">get / set 方法的this</span></li><br></ul><br><pre class="lang:default decode:true">function func(){return this.a + this.b;}<br>var obj = {a: 1, b: 2, get sum(){return this.a + this.b;}};<br>Object.defineProperty(obj, ‘sum2’, {get: func, enumerable: true, configurable: true});<br>o.sum;<br>o.sum2;<br><br>// 3<br>// 3</pre><br>这里可以看出 get set方法的this 不论是动态添加到对象里的 还是通过对象字面量申明的 this指向的都还是o这个对象<br><br></div><br><ul><br>     <li><span style="color: #339966;">构造器中的this</span></li><br></ul><br><pre class="lang:js decode:true">function klass(){this.a = 1;}<br>var  o = new klass();<br>o.a; // 1<br>function klass2(){this.a = 2; return {a:3};}<br>o = new klass2();<br>o.a; // 3<br></pre><br>在一般的函数中 this会指向window对象<br><br>但是通过构造函数申明对象的时候 this会指向一个空对象 并且他的原型会指向他继承而来的对象 如果函数没有返回值 那么this就会作为返回值返回<br><br>但是有返回值 且这个返回值是对象的时候 这个对象就会作为返回值返回<br><ul><br>     <li><span style="color: #339966;">call / apply方法与this</span></li><br></ul><br>call和apply都是可以修改函数执行时候的this的指向的方法<br><br>call和apply没有太大差别 在传递参数的时候 第一个参数是想作为this的对象 剩下的参数是传入这个函数的参数 但是call在传函数参数的时候使用逗号分割 而apply使用的是数组的形式传入<br><pre class="lang:default decode:true ">function add(c, d){return this.a + this.b + this.c + this.d;}<br>var o = {a: 1, b: 2};<br>add.call(o, 3, 4);       // 1 + 2 + 3 + 4 = 10<br>add.apply(o, [5, 6]);    // 1 + 2 + 5 + 6 = 14<br>function bar(){alert(Object.prototype.toString.call(this));}<br>bar.call(7)              // [object Number]</pre><br><ul><br>     <li><span style="color: #339966;">bind方法与this 【bind方法是ES5提供的】</span></li><br></ul><br>bind方法的内容就会多一些 并且bind 方法是ES5提供的 所以IE的话要IE9 + 才会支持<br><br><span style="color: #3366ff;"><strong>首先是bind方法可以绑定this</strong></span><br><br>bind方法是由一个对象参数 传入想作为this的对象<br><pre class="lang:default decode:true">function func(){return this.a;}<br>var g = func.bind({a: “test”});<br>g();             // test<br>var  obj = {a: 123, f: func, g: g};<br>obj.f()            // 123<br>o.g()            // test</pre><br>从这里可以看到 对func用bind进行了一次操作 {a: “test”}这个对象就一直绑定在了上面<br><br>所以g的this一直会指向这个传入的字面量对象<br><br>即使到后来这个g属于了另一个对象 但是他的this依然会指向bind绑定的对象<br><br>但是如果传入的参数是undefined或者null 那么不会修改this对象<br><br>再看一个小例子<br><pre class="lang:default decode:true ">this.x = 9;<br>var module = {x: 81, getX: function(){return this.x;}};<br>module.getX();                   // 81<br>var getX = module.getX;<br>getX();                          // 9<br>var boundGetX = getX.bind(module);<br>boundGetX();                     // 81</pre><br>理解一下就行<br><br><span style="color: #3366ff;"><strong>然后是 bind 与 currying</strong></span><br><br>currying这里指的就是函数的柯里化<br><br>柯里化呢 就是把一个函数拆分城多个单元<br><br>具体什么意思看个例子就知道了<br><pre class="lang:js decode:true">function add(a, b, c){return a + b + c;}<br>var func = add.bind(undefined, 100);<br>func(1, 2)                          // 103<br>var func2 = func.bind(undefined, 200);<br>func2(10)                           // 310</pre><br>看var fund = add.bind(undefined, 100); 这行代码<br><br>其中 bind方法传入了两个参数 第一个是undefined 表示不修改this的指向 然后跟了一个参数是100 这里的第二个参数开始 就是指被bind函数的需要绑定的参数<br><br>也就是说 这里的100 传给了 add(a, b, c)里的a 并且做了绑定 这里的a就一直是100了<br><br>然后再用func(1, 2)返回的就是103 内部操作其实就是 100 + b + c 我们传了1给b 穿了2给c 所以返回了103<br><br>柯里化具体的应用也不少<br><br>比如<br><pre class="lang:js decode:true  ">function getConfig(address, username, password, otherOptions){<br>  console.log(address, username, password, otherOptions);<br>}<br>var defaultConfig = getConfig.bind(null, “127.0.0.1”, “nisal”, “zxc123”);<br>defaultConfig(“none”);<br>defaultConfig(“2MB”);</pre><br>这里就是做一个默认配置的应用<br><br><span style="color: #3366ff;"><strong>bind 与 new</strong></span><br><pre class="lang:js decode:true ">function foo(){this.a = 1; return this.b;}<br>var func = foo.bind({b: 2});<br>func();                         // 2<br>new func();                     // {a: 1}</pre><br><div><br><div>这里前面三行已经很好理解了 通过bind绑定了一个字面量对象 所以在调用func的时候 他的this就会指向这个字面亮对象 返回一个3</div><br><div></div><br><div>但是当使用new操作 再new func() 这时候之前的bind操作就会被忽略掉</div><br><div></div><br><div>也就是说 new func()之后的新对象产生了一个this 这个this为中并且原型指向了foo.prototype</div><br></div><br><div></div><br><div><br><div>然后对象的a属性会被置1 最后this就作为返回值返回 并且忽略掉了return this.b</div><br><div></div><br><div><br><br><hr><br><br></div><br><div><br><h1><strong><span style="color: #ff0000;">函数属性 &amp; arguments</span></strong></h1><br><pre class="lang:js decode:true ">function foo(x, y, z){<br>  arguments.length;                // 2<br>  arguments[0];                    // 1<br>  x;                               // 1<br>  arguments[0] = 10;<br>  x;                               // 10<br><br>  z;                               // undefined<br>  arguments[2] = 100;<br>  z;                               // undefined<br>  arguments.callee === foo;        // true<br>}<br>foo(1, 2);<br>foo.length;                        // 3<br>foo.name;                          // foo</pre><br><div><br><div>函数属性呢 有一些</div><br><div>比如</div><br><div></div><br><div>func.length 返回可以传入的参数个数</div><br><div>func.name  返回函数名</div><br><div></div><br><div><br><div>但是有时候传入的参数 并不是实际可以传入的个数</div><br><div>可以在函数内使用arguments.length获得实际传入的参数个数</div><br><div>arguments是一个类数组的对象 但是他的原型不指向Array</div><br><div>如果没有穿参数 arguuments和对应的参数是不能修改的</div><br><div>另外在严格模式下 arguments不能修改参数的值 并且arguments.callee也是禁止的</div><br></div><br></div><br></div><br></div></div></header></article><!--div.comments#lv-container(data-id = theme.livere_id, data-uid = theme.livere_uid)//script.
  //(function(d, s) {var j, e = d.getElementsByTagName(s)[0];if (typeof LivereTower === 'function') { return; } j = d.createElement(s);j.src = 'https://cdn-city.livere.com/js/embed.dist.js';j.async = true;e.parentNode.insertBefore(j, e);})(document, 'script');--></main><footer class="foot"><div class="foot-copy">&copy; 2017-2018 NISAL</div></footer><script src="/js/scroller.js"></script><script src="/js/main.js"></script></body></html>