<!DOCTYPE html><html lang="zh-CN"><head><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1"><meta name="author" content="NISAL"><link rel="alternative" href="/atom.xml" title="HIσ`∀´)σNISAL" type="application/atom+xml"><link rel="icon" href="/favicon.png"><title>【前端性能优化】部分笔记 - HIσ`∀´)σNISAL</title><link rel="stylesheet" href="/css/main.css"><link rel="stylesheet" href="/js/fancybox/jquery.fancybox.min.css"><!--[if lt IE 9]><script>(function(a,b){a="abbr article aside audio bdi canvas data datalist details dialog figcaption figure footer header hgroup main mark meter nav output progress section summary template time video".split(" ");for(b=a.length-1;b>=0;b--)document.createElement(a[b])})()</script><![endif]--><script src="/js/jquery-3.1.1.min.js"></script><script src="/js/fancybox/jquery.fancybox.min.js"></script></head><body style="opacity:0"><header class="head"><h1 class="head-title u-fl"><a href="/">HIσ`∀´)σNISAL</a></h1><nav class="head-nav u-fr"><ul class="head-nav__list"><li class="head-nav__item"><a class="head-nav__link" href="/archives">カタログ/（目录）</a></li></ul></nav></header><main class="main"><article class="post"><header class="post__head"> <time class="post__time" datetime="2018-04-26T12:34:24.000Z">April 26, 2018</time><h1 class="post__title"><a href="/2018/04/26/【前端性能优化】部分笔记/">【前端性能优化】部分笔记</a></h1><div class="post__main echo"><blockquote>
<p>深入理解 http 请求的过程 是前端性能优化的核心</p>
</blockquote>
<h2 id="资源合并于压缩"><a href="#资源合并于压缩" class="headerlink" title="资源合并于压缩"></a>资源合并于压缩</h2><h3 id="目的"><a href="#目的" class="headerlink" title="目的"></a>目的</h3><ol>
<li>减少http请求数量</li>
<li>减少请求的资源大小</li>
</ol>
<h3 id="具体"><a href="#具体" class="headerlink" title="具体"></a>具体</h3><ul>
<li>html压缩</li>
<li>css压缩</li>
<li>js的压缩与混乱</li>
<li>文件合并</li>
<li>开启gzip</li>
</ul>
<h4 id="HTML压缩"><a href="#HTML压缩" class="headerlink" title="HTML压缩"></a>HTML压缩</h4><blockquote>
<p>html代码压缩就是压缩这些在文本中有意义 但在html中不显示的字符 包括空格、制表符、换行符等 还有一些其他意义的字符 比如html注释</p>
</blockquote>
<p>如何进行html压缩</p>
<ol>
<li>使用在线网站</li>
<li>nodejs提供的工具</li>
<li>后端模板引擎渲染压缩</li>
</ol>
<h4 id="CSS压缩"><a href="#CSS压缩" class="headerlink" title="CSS压缩"></a>CSS压缩</h4><ul>
<li>无效代码删除</li>
<li>css语义合并</li>
</ul>
<p>如何压缩css</p>
<ol>
<li>使用在线网站</li>
<li>使用nodejs工具</li>
</ol>
<h4 id="js的压缩与混乱"><a href="#js的压缩与混乱" class="headerlink" title="js的压缩与混乱"></a>js的压缩与混乱</h4><ul>
<li>无效字符的山吹</li>
<li>剔出注释</li>
<li>代码语义的缩减和优化</li>
<li>代码保护</li>
</ul>
<p>如何压缩js</p>
<ol>
<li>使用在线网站</li>
<li>使用nodejs工具</li>
<li>…</li>
</ol>
<h4 id="文件合并"><a href="#文件合并" class="headerlink" title="文件合并"></a>文件合并</h4><p>合并存在的问题</p>
<ol>
<li>首屏渲染问题</li>
<li>缓存失效问题</li>
</ol>
<p>如何实现文件合并</p>
<ol>
<li>在线网站</li>
<li>nodejs工具</li>
</ol>
<hr>
<h2 id="图片相关优化"><a href="#图片相关优化" class="headerlink" title="图片相关优化"></a>图片相关优化</h2><h3 id="PNG8-PNG24-PNG32的区别"><a href="#PNG8-PNG24-PNG32的区别" class="headerlink" title="PNG8/PNG24/PNG32的区别"></a>PNG8/PNG24/PNG32的区别</h3><ul>
<li>png8 - 256色 支持透明</li>
<li>png24 - 2^24色 不支持透明</li>
<li>png32 - 2^24色 支持透明</li>
</ul>
<h3 id="JPG"><a href="#JPG" class="headerlink" title="JPG"></a>JPG</h3><p>…</p>
<blockquote>
<p>每种图片格式都有自己的特点 针对不同的业务场景选择不同的图片格式很重要</p>
</blockquote>
<h3 id="不同格式图片对比"><a href="#不同格式图片对比" class="headerlink" title="不同格式图片对比"></a>不同格式图片对比</h3><ul>
<li>jpg有损压缩 压缩率高 不支持透明</li>
<li>png支持透明 浏览器兼容好</li>
<li>webp压缩成都更好 再ios webview有兼容性问题</li>
<li>svg矢量图 代码内嵌 相对较小 图片样式相对简单的场景</li>
</ul>
<h3 id="常用业务场景"><a href="#常用业务场景" class="headerlink" title="常用业务场景"></a>常用业务场景</h3><ul>
<li>jpg - 大部分不需要透明图片的业务场景</li>
<li>png - 大部分需要透明图片的业务场景</li>
<li>webp - 安卓全部</li>
<li>svg矢量图 - 图片样式相对简单的业务场景</li>
</ul>
<h3 id="图片压缩"><a href="#图片压缩" class="headerlink" title="图片压缩"></a>图片压缩</h3><blockquote>
<p>针对真是图片的情况 舍弃一些相对无关紧要的色彩信息</p>
</blockquote>
<h3 id="CSS雪碧图"><a href="#CSS雪碧图" class="headerlink" title="CSS雪碧图"></a>CSS雪碧图</h3><blockquote>
<p>把网站上用到的一些图片整合到单独的图片中 可以减少http请求数量</p>
</blockquote>
<h3 id="Image-inline"><a href="#Image-inline" class="headerlink" title="Image inline"></a>Image inline</h3><blockquote>
<p>将图片的内容内嵌到html中 减少http请求数</p>
</blockquote>
<h3 id="使用矢量图"><a href="#使用矢量图" class="headerlink" title="使用矢量图"></a>使用矢量图</h3><blockquote>
</blockquote>
<p>使用SVG进行矢量图的绘制 使用iconfont解决icon问题</p>
<h3 id="在安卓下使用webp"><a href="#在安卓下使用webp" class="headerlink" title="在安卓下使用webp"></a>在安卓下使用webp</h3><blockquote>
<p>WebP的优势体现在它具有更优的图像数据压缩算法 能带来更小的图片体积 而且拥有肉眼识别无差异的图像质量 同时具备了无损和有损的压缩模式 alpha透明以及动画的特性 在jpeg和png上的转化效果都非常优秀  稳定 和统一</p>
</blockquote>
<hr>
<h2 id="CSS-JS-的加载与执行"><a href="#CSS-JS-的加载与执行" class="headerlink" title="CSS / JS 的加载与执行"></a>CSS / JS 的加载与执行</h2><h3 id="HTML渲染过程的一些特点"><a href="#HTML渲染过程的一些特点" class="headerlink" title="HTML渲染过程的一些特点"></a>HTML渲染过程的一些特点</h3><ul>
<li>顺序执行 并发加载</li>
<li>是否阻塞</li>
<li>依赖关系</li>
<li>引入方式</li>
</ul>
<h4 id="顺序执行-并发加载"><a href="#顺序执行-并发加载" class="headerlink" title="顺序执行 并发加载"></a>顺序执行 并发加载</h4><ul>
<li>词法分析</li>
<li>并发加载</li>
<li>并发上限(再某个域名下并发请求数有上限)</li>
</ul>
<h4 id="CSS阻塞"><a href="#CSS阻塞" class="headerlink" title="CSS阻塞"></a>CSS阻塞</h4><ul>
<li>CSS head中阻塞页面渲染</li>
<li>CSS 阻塞js渲染</li>
<li>CSS 不阻塞外部脚本的加载</li>
</ul>
<h4 id="JS阻塞"><a href="#JS阻塞" class="headerlink" title="JS阻塞"></a>JS阻塞</h4><ul>
<li>直接引入的js阻塞页面的渲染</li>
<li>js不阻塞资源的加载</li>
<li>js顺序执行 阻塞后续js逻辑的执行</li>
</ul>
<hr>
<h2 id="重绘与回流"><a href="#重绘与回流" class="headerlink" title="重绘与回流"></a>重绘与回流</h2><h3 id="css性能让js变慢"><a href="#css性能让js变慢" class="headerlink" title="css性能让js变慢?"></a>css性能让js变慢?</h3><p>UI线程和JS线程同一时间只有一个再运作 所以这个问题是成立的(频繁触发重绘于回流 会导致UI频繁渲染 最终导致JS变慢)</p>
<h3 id="什么是重绘与回流"><a href="#什么是重绘与回流" class="headerlink" title="什么是重绘与回流"></a>什么是重绘与回流</h3><blockquote>
<p>回流<br>当render tree中的一部分(或全部)因为元素的规模尺寸 布局 隐藏等改变而需要重新构建 这就称为回流<br>当页面布局和几何属性改变时就需要回流</p>
</blockquote>
<blockquote>
<p>重绘<br>当render tree中的一些元素需要更新属性 而这些属性只是影响元素的外观 风格 而不会影响布局的 比如background-color 则就叫重绘</p>
</blockquote>
<p>回流必定引起重绘 而重绘不一定引起回流</p>
<h3 id="触发页面重布局的属性"><a href="#触发页面重布局的属性" class="headerlink" title="触发页面重布局的属性"></a>触发页面重布局的属性</h3><ul>
<li>盒子模型相关属性会触发重布局</li>
<li>定位属性及浮动也会触发重布局</li>
<li>改变节点内部文字结构也会触发重布局</li>
</ul>
<p>会触发页面重布局的属性(触发回流)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">width/height/padding/margin/display/border/border-width/min-height/top/bottom/left/right/position/float/clear/text-align/overflow-y/font-weight/overflow/font-family/line-height/vertical-align/white-space/font-size</span><br></pre></td></tr></table></figure></p>
<p>只会触发重绘的属性<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">color/border-style/border-radius/visibility/text-decoration/background/background-image/background-position/background-repeat/background-size/outline-color/outline/outline-style/outline-width/box-shadow</span><br></pre></td></tr></table></figure></p>
<h3 id="新建DOM的过程"><a href="#新建DOM的过程" class="headerlink" title="新建DOM的过程"></a>新建DOM的过程</h3><ol>
<li>获取DOM后分割为多个图层</li>
<li>对每个图层的节点计算样式结果(Recalculate style – 样式重计算)</li>
<li>为每个节点生成图形和位置(Layout – 回流和重布局)</li>
<li>将每个节点绘制填充到图层位图中(Paint Setup和Paint – 重绘)</li>
<li>土层作为纹理上传至GPU</li>
<li>符合多个图层到页面上生成最终屏幕图像(Composite Layers – 图层重组)</li>
</ol>
<blockquote>
<p>将频繁重绘回流的DOM元素单独作为一个独立图层 那么这个DOM元素的重绘和回流的影响只会再这个图层中</p>
</blockquote>
<h3 id="如何将DOM元素变成新的独立图层"><a href="#如何将DOM元素变成新的独立图层" class="headerlink" title="如何将DOM元素变成新的独立图层"></a>如何将DOM元素变成新的独立图层</h3><h4 id="chrome创建图层的条件"><a href="#chrome创建图层的条件" class="headerlink" title="chrome创建图层的条件"></a>chrome创建图层的条件</h4><ol>
<li>3D或透视变换CSS属性(perspective transform)</li>
<li>使用加速视频解码的<video>节点</video></li>
<li>拥有3D(WEB GL)上下文或加速的2D上下文的<canvas>节点</canvas></li>
<li>混合插件(比如flash)</li>
<li>对自己的opacity做css动画或使用一个动画webkit变换的元素</li>
<li>拥有加速CSS过滤器的元素</li>
<li>子元素有包含复合层的后代节点(一个元素拥有子元素 该子元素在自己的层里)</li>
<li>元素拥有一个z-index较低且包含一个复合层的兄弟元素(换句话说该元素再复合层上渲染)</li>
</ol>
<h4 id="图层不能被滥用"><a href="#图层不能被滥用" class="headerlink" title="图层不能被滥用"></a>图层不能被滥用</h4><p>图层一多 在图层重组的情况下会十分消耗性能</p>
<h3 id="优化方案"><a href="#优化方案" class="headerlink" title="优化方案"></a>优化方案</h3><ol>
<li>用translate替代top改变 (top触发回流 但是translate不会)</li>
<li>用opacity替代visibility</li>
<li>不要一条一条地修改DOM的样式 预先定义好class 然后修改DOM的className</li>
<li>把DOM离线后修改 比如: 把DOM给display:none(有一次reflow) 然后修改100次 然后再显示出来</li>
<li>不要把DOM节点的属性值放在一个循环里当成循环里的变量</li>
<li>不要使用table布局 可能一个小的改动会造成整个table的重新布局</li>
<li>动画实现的速度选择</li>
<li>对于动画新建图层</li>
<li>启用GPU硬件加速</li>
</ol>
<hr>
<h2 id="浏览器存储"><a href="#浏览器存储" class="headerlink" title="浏览器存储"></a>浏览器存储</h2><h3 id="Cookie"><a href="#Cookie" class="headerlink" title="Cookie"></a>Cookie</h3><blockquote>
<p>因为http请求无状态 所以需要cookie去维持客户端状态</p>
</blockquote>
<p>作用</p>
<ol>
<li>用于浏览器和服务端的交互</li>
<li>客户端自身存取数据</li>
</ol>
<p>cookie存储是限制</p>
<ol>
<li>作为浏览器存储 大小4KB左右</li>
<li>需要设置过期时间expire</li>
</ol>
<p>cookie存储数据能力被localstorage取代<br>cookie还可以设置httponly 不允许js读写<br>cookie再相关域名下面的所有请求都会被带上(cdn的流量损耗 尽量cdn域名和主站域名要分开)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// 读取Cookie</span><br><span class="line">document.cookie</span><br><span class="line"></span><br><span class="line">// 写Cookie</span><br><span class="line">document.cookie = &apos;a=1&apos;</span><br><span class="line">document.cookie = &apos;b=2&apos;</span><br></pre></td></tr></table></figure>
<h3 id="LocalStorage"><a href="#LocalStorage" class="headerlink" title="LocalStorage"></a>LocalStorage</h3><ul>
<li>HTML5这几出来专门用于浏览器存储的</li>
<li>大小约为5M</li>
<li>仅在客户端使用 不和服务端进行通信</li>
<li>接口封装较好</li>
<li>浏览器本地缓存方案</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// 写</span><br><span class="line">localStorage.setItem(key, value)</span><br><span class="line"></span><br><span class="line">// 读</span><br><span class="line">localStorage.getItem(key)</span><br></pre></td></tr></table></figure>
<h3 id="SessionStorage"><a href="#SessionStorage" class="headerlink" title="SessionStorage"></a>SessionStorage</h3><ul>
<li>回话级别的浏览器存储</li>
<li>大小为5M左右</li>
<li>尽在客户端使用 不和服务端进行通信</li>
<li>接口封装较好</li>
<li>对于表单信息的维护</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// 写</span><br><span class="line">sessionStorage.setItem(key, value)</span><br><span class="line"></span><br><span class="line">// 读</span><br><span class="line">sessionStorage.getItem(key)</span><br></pre></td></tr></table></figure>
<h3 id="IndexedDB"><a href="#IndexedDB" class="headerlink" title="IndexedDB"></a>IndexedDB</h3><blockquote>
<p>一种低级API 用于客户端存储大量结构化数据 该API使用索引来实现对该数据的高性能搜索 虽然Web Storage对于存储少量的数据很有用 但是对于存储更大量的结构化数据来说 这种方法不太有用 IndexedDB提供了一个解决方案<br>可以为应用创建离线版本</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line">// 建立一个indexedDB库</span><br><span class="line">let db = indexedDB.open(&apos;dbname&apos;)</span><br><span class="line">let dbobj = null;</span><br><span class="line"></span><br><span class="line">// 控制indexeddb</span><br><span class="line">db.onerror = function(e) &#123;</span><br><span class="line">    // 开启失败的回调</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">request.onupgradeneeded = function() &#123;</span><br><span class="line">    // 没有数据库到建库或者修改版本的时候会触发</span><br><span class="line">    </span><br><span class="line">    // 数据建模</span><br><span class="line">    let store = dbobj.createObjectStore(&apos;person&apos;, &#123;</span><br><span class="line">        // key设定</span><br><span class="line">        keyPath: &apos;id&apos;</span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">    let nameIndex = store.createIndex(&apos;by_name&apos;, &apos;name&apos;, &#123;</span><br><span class="line">        unique: true</span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">    let nameIndex = store.createIndex(&apos;by_age&apos;, &apos;age&apos;);</span><br><span class="line">    </span><br><span class="line">    store.put(&#123;</span><br><span class="line">        name: &apos;nisal&apos;,</span><br><span class="line">        age: 14,</span><br><span class="line">        id: 0</span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">    store.put(&#123;</span><br><span class="line">        name: &apos;nisal2&apos;,</span><br><span class="line">        age: 15,</span><br><span class="line">        id: 1</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">db.onsuccess = function(e) &#123;</span><br><span class="line">    // 开启成功的回调</span><br><span class="line">    console.log(e);</span><br><span class="line">    dbobj = e.target.result;</span><br><span class="line"></span><br><span class="line">    // 插入数据</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 事务 (用来操作object store)</span><br><span class="line">function addData(db) &#123;</span><br><span class="line">    let transaction = db.transaction(&apos;person&apos;, &apos;readwrite&apos;);</span><br><span class="line">    let store = transaction.objectStore(&apos;person&apos;);</span><br><span class="line">    </span><br><span class="line">    // 获取当前库中的数据</span><br><span class="line">    let req = store.get(0)  // 传入key</span><br><span class="line">    req.onsuccess = function(e) &#123;</span><br><span class="line">        console.log(e.target.result)  // 结果</span><br><span class="line">        </span><br><span class="line">        // 更新</span><br><span class="line">        let p = e.target.result;</span><br><span class="line">        p.name = &apos;sb&apos;;</span><br><span class="line">        let uReq = store.put(p);</span><br><span class="line">        uReq.onsuccess = function(e) &#123;</span><br><span class="line">            console.log(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    // 添加</span><br><span class="line">    store.add(&#123;</span><br><span class="line">        name: &apos;nisal3&apos;,</span><br><span class="line">        age: 16,</span><br><span class="line">        id: 2</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 关闭indexedDB</span><br><span class="line">dbobj.close();</span><br><span class="line"></span><br><span class="line">// 删库</span><br><span class="line">indexedDB.deleteDatabase(dbobj);</span><br></pre></td></tr></table></figure>
<h3 id="Service-Workers"><a href="#Service-Workers" class="headerlink" title="Service Workers"></a>Service Workers</h3><blockquote>
<p>Service Worker是一个脚本 浏览器独立于当前页面 将其在后台运行 为实现一些不依赖页面或者用户交互的特性打开了一扇大门 在未来这些特性将包括消息推送 背景后台同步 geofencing(地理围栏定位) 但它将推出的第一个首要特性 就是拦截和处理请求网络请求的能力 包括以变成方式来管理被缓存的响应</p>
</blockquote>
<h4 id="产生的意义"><a href="#产生的意义" class="headerlink" title="产生的意义"></a>产生的意义</h4><p>当加载或者渲染资源比较庞大的时候 会导致页面的阻塞 所以需要开一条新的线程来进行运算</p>
<h4 id="Chrome调试工具"><a href="#Chrome调试工具" class="headerlink" title="Chrome调试工具"></a>Chrome调试工具</h4><ul>
<li>chrome://serviceworker-internals/</li>
<li>chrome://inspect/#service-workers</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">// 离线化</span><br><span class="line"></span><br><span class="line">// service-worker.js</span><br><span class="line"></span><br><span class="line">self.addEventListener(&apos;install&apos;, function(e) &#123;</span><br><span class="line">    e.waitUntil(</span><br><span class="line">        caches.open(&apos;app-v1&apos;).then(function(cache) &#123;</span><br><span class="line">            console.log(&apos;cache.open&apos;);</span><br><span class="line">            return cache.addAll([</span><br><span class="line">                &apos;app.js&apos;,</span><br><span class="line">                &apos;main.css&apos;</span><br><span class="line">            ]);</span><br><span class="line">        &#125;);</span><br><span class="line">    );</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">self.addEventListener(&apos;fetch&apos;, function(event) &#123;</span><br><span class="line">    event.respondWith(</span><br><span class="line">        caches.match(&apos;event.request&apos;).then(function(res) &#123;</span><br><span class="line">            if (res) &#123;</span><br><span class="line">                return res;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                // 通过fetch方法向网络发请求</span><br><span class="line">                fetch(url).then(function(res) &#123;</span><br><span class="line">                    // 对于新请求的资源存储到cachestorage中</span><br><span class="line">                &#125;);</span><br><span class="line">                </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    )</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// app.js</span><br><span class="line">navigator.serviceWorker.register(&apos;./service-worker&apos;.js, &#123;scope: &apos;./&apos;&#125;).then(function(reg) &#123;</span><br><span class="line">    console.log(reg);</span><br><span class="line">&#125;).catch(function(e) &#123;</span><br><span class="line">    console.log(e);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h3 id="PWA"><a href="#PWA" class="headerlink" title="PWA"></a>PWA</h3><p>PWA(Progressive Web Apps)是一种Web App新模型 并不是具体指某一种前沿技术或某一个单一的知识点 我们从英文缩写就能看出 这是一个叫渐进式的WebAPP 是通过一系列新的Web特性 配合优秀的UI交互设计 逐步增强Web App的用户体验</p>
<ul>
<li>可靠: 在没有网络的环境中也能提供基本的页面访问 而不会出现“未连接到互联网”的页面</li>
<li>快速：针对网页渲染及网络数据访问又较好的优化</li>
<li>融入：应用可以被增加到手机桌面 并且和普通应用意义又全屏 推送等特性</li>
</ul>
<hr>
<h2 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h2><p>建立自动化的 客户端和服务端进行协商的缓存机制 通过httpheader来协商的缓存策略</p>
<h3 id="Cache-Control"><a href="#Cache-Control" class="headerlink" title="Cache-Control"></a>Cache-Control</h3><ul>
<li>max-age (再max-age设置的这段时间内 浏览器不会向服务端发起请求)</li>
<li>s-maxage (优先级高于max-age 和max-age一样 指定一个缓存的有效时间 但是只能访问public的缓存 比如cdn)</li>
<li>private</li>
<li>public</li>
<li>no-cache (不会像max-age一样 不发起请求直接读缓存 而是像服务端询问要不要用缓存)</li>
<li>no-store (不使用任何缓存策略)</li>
</ul>
<h3 id="Expires-max-age优先级更高-有max-age的时候-expires就会被忽略"><a href="#Expires-max-age优先级更高-有max-age的时候-expires就会被忽略" class="headerlink" title="Expires(max-age优先级更高 有max-age的时候 expires就会被忽略)"></a>Expires(max-age优先级更高 有max-age的时候 expires就会被忽略)</h3><ul>
<li>缓存过期时间 用来指定资源到期的时间 是服务端的具体的时间点</li>
<li>告诉浏览器再过期时间前浏览器可以直接从浏览器缓存取数据 而无需再次请求</li>
</ul>
<h3 id="Last-Modified-If-Modified-Singe-感知服务端文件是否发生变化"><a href="#Last-Modified-If-Modified-Singe-感知服务端文件是否发生变化" class="headerlink" title="Last-Modified / If-Modified-Singe (感知服务端文件是否发生变化)"></a>Last-Modified / If-Modified-Singe (感知服务端文件是否发生变化)</h3><p>对比文件的最后修改时间</p>
<ul>
<li>基于客户端和服务端协商的缓存机制</li>
<li>last-modified - response header</li>
<li>if-modified-since - request header</li>
<li>需要与cache-control共同使用 (max-age过期后 去服务端通过last-modified进行协商)</li>
</ul>
<h3 id="Last-modofied缺点"><a href="#Last-modofied缺点" class="headerlink" title="Last-modofied缺点"></a>Last-modofied缺点</h3><ul>
<li>某些服务端不能获取精确的修改时间</li>
<li>文件修改时间改了 但是文件内容没有变</li>
</ul>
<h3 id="Etag-If-None-Match"><a href="#Etag-If-None-Match" class="headerlink" title="Etag / If-None-Match"></a>Etag / If-None-Match</h3><p>回来的时候etag上有文件的hash 上去的时候通过if-none-match携带hash 做对比</p>
<ul>
<li>传递文件内容的hash值</li>
<li>etag - response header</li>
<li>if-none-match - request header</li>
<li>需要与cache-control共同使用</li>
</ul>
<hr>
<h2 id="服务端性能优化"><a href="#服务端性能优化" class="headerlink" title="服务端性能优化"></a>服务端性能优化</h2><h3 id="VUE渲染面临的问题是什么"><a href="#VUE渲染面临的问题是什么" class="headerlink" title="VUE渲染面临的问题是什么"></a>VUE渲染面临的问题是什么</h3><p>下载vue.js -&gt; 执行vue.js代码 -&gt; 生成html页面</p>
<p>需要加载所有的资源 需要等待 前端生成html页面 相对传统的服务端生成好html传回更耗费时间</p>
<h3 id="怎么在vue层面对性能进行提升"><a href="#怎么在vue层面对性能进行提升" class="headerlink" title="怎么在vue层面对性能进行提升"></a>怎么在vue层面对性能进行提升</h3><h4 id="多层次的优化方案"><a href="#多层次的优化方案" class="headerlink" title="多层次的优化方案"></a>多层次的优化方案</h4><ul>
<li>构建层模板编译 (在构建的过程中将模板编译成vue可以直接执行的脚本 而不需要在执行的时候编译)</li>
<li>数据无关的prerender的方式(比较通用的 数据无关的页面 在构建过程中直接构建成html 不需要运行的时候编译)</li>
<li>服务端渲染(SSR)</li>
</ul>
</div></header></article><!--div.comments#lv-container(data-id = theme.livere_id, data-uid = theme.livere_uid)//script.
  //(function(d, s) {var j, e = d.getElementsByTagName(s)[0];if (typeof LivereTower === 'function') { return; } j = d.createElement(s);j.src = 'https://cdn-city.livere.com/js/embed.dist.js';j.async = true;e.parentNode.insertBefore(j, e);})(document, 'script');--></main><footer class="foot"><div class="foot-copy">&copy; 2017-2018 NISAL</div></footer><script src="/js/scroller.js"></script><script src="/js/main.js"></script><script src="/live2dw/lib/L2Dwidget.min.js?0c58a1486de42ac6cc1c59c7d98ae887"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","model":{"jsonPath":"/live2dw/assets/01/assets/haru01.model.json"}});</script></body></html>