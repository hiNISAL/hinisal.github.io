<!DOCTYPE html><html lang="zh-CN"><head><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1"><meta name="author" content="NISAL"><link rel="alternative" href="/atom.xml" title="HIσ`∀´)σNISAL" type="application/atom+xml"><link rel="icon" href="/favicon.png"><title>【Koa】使用装饰器处理路由 - HIσ`∀´)σNISAL</title><link rel="stylesheet" href="/css/main.css"><link rel="stylesheet" href="/js/fancybox/jquery.fancybox.min.css"><!--[if lt IE 9]><script>(function(a,b){a="abbr article aside audio bdi canvas data datalist details dialog figcaption figure footer header hgroup main mark meter nav output progress section summary template time video".split(" ");for(b=a.length-1;b>=0;b--)document.createElement(a[b])})()</script><![endif]--><script src="/js/jquery-3.1.1.min.js"></script><script src="/js/fancybox/jquery.fancybox.min.js"></script></head><body style="opacity:0"><header class="head"><h1 class="head-title u-fl"><a href="/">HIσ`∀´)σNISAL</a></h1><nav class="head-nav u-fr"><ul class="head-nav__list"><li class="head-nav__item"><a class="head-nav__link" href="/archives">カタログ/（目录）</a></li></ul></nav></header><main class="main"><article class="post"><header class="post__head"> <time class="post__time" datetime="2018-05-21T14:09:44.000Z">May 21, 2018</time><h1 class="post__title"><a href="/2018/05/21/【Koa】使用装饰器处理路由/">【Koa】使用装饰器处理路由</a></h1><div class="post__main echo"><p>今天尝试着在Koa中 使用<code>装饰器</code> + <code>Koa-Router</code>完成路由的处理 目前基本上已经成功了</p>
<p>看一下使用时候的效果吧</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">import &#123; controller, get, logged &#125; from &apos;../../decorators/route&apos;;</span><br><span class="line"></span><br><span class="line">@controller(&apos;/api/v0/user&apos;)</span><br><span class="line">class User &#123;</span><br><span class="line">  @get(&apos;/users&apos;)</span><br><span class="line">  @logged</span><br><span class="line">  async log(ctx, next) &#123;</span><br><span class="line">    console.log(&apos;ola!&apos;);</span><br><span class="line">    await next();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @get(&apos;/users&apos;)</span><br><span class="line">  async allUsers(ctx, next) &#123;</span><br><span class="line">    ctx.body = [&#123; id: 1, name: &apos;a&apos; &#125;, &#123; id: 2, name: &apos;b&apos; &#125;];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>我们对<code>User</code>累进行了装饰 表示这个类是个控制器 控制了 <code>/api/v0/user</code> 这个路由下的所有子路由的处理</p>
<p>然后在里面 我们有一个<code>log</code>方法 对他用<code>get</code>和<code>logged</code>进行了装饰 分别表示这个当<code>get</code>到<code>/api/v0/user/users</code>这个路由的时候 进行处理</p>
<p>然后往下走 走到了<code>logged</code>装饰器 这个装饰器的作用就是判断是否登陆 这里有个难点 装饰器只是普通的函数 如何把他转成一个正二八斤的中间件 这个问题等下再探讨</p>
<h2 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h2><p>装饰器是目前是ES6中的一个<code>提案</code> 所以不论是node还是浏览器 都是不支持的</p>
<p>所以这里使用<code>babel</code>配合<code>babel</code>的插件 来对我们的代码进行编译</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// .babelrc</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">  &quot;presets&quot;: [</span><br><span class="line">    &quot;env&quot;,</span><br><span class="line">    &quot;stage-0&quot;</span><br><span class="line">  ],</span><br><span class="line">  &quot;plugins&quot;: [</span><br><span class="line">    &quot;transform-decorators-legacy&quot;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>主要用到的是<code>transform-decorators-legacy</code>插件</p>
<p>其实就是下面这三个依赖</p>
<ul>
<li>babel</li>
<li>babel-core</li>
<li>babel-polyfill</li>
<li>babel-plugin-transform-decorators-legacy</li>
</ul>
<p>这些是编译需要的</p>
<p>然后就是我们的<code>Koa</code> <code>Koa-Router</code> <code>glob</code></p>
<p><code>glob</code>可以帮助我们去获取文件路径</p>
<h2 id="目录结构"><a href="#目录结构" class="headerlink" title="目录结构"></a>目录结构</h2><p>目录结构很简单<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">|- node_modules</span><br><span class="line">|- src</span><br><span class="line">  |- app.js       // 程序入口</span><br><span class="line">  |- decorators</span><br><span class="line">    |- route.js   // 和路由相关的装饰器都在这里</span><br><span class="line">  |- middlewares</span><br><span class="line">    |- router.js  // 创建路由</span><br><span class="line">  |- router</span><br><span class="line">    |- admin</span><br><span class="line">      |- admin.js // admin路由业务</span><br><span class="line">|- index.js       // babel运行环境</span><br><span class="line">|- .babelrc</span><br><span class="line">|- package.json</span><br><span class="line">|- package-lock.json</span><br></pre></td></tr></table></figure></p>
<h2 id="index-js"><a href="#index-js" class="headerlink" title="index.js"></a>index.js</h2><p>这个文件其实就是跑一个babel的环境 这样我们的代码就会被编译</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">require(&apos;babel-core/register&apos;);</span><br><span class="line">require(&apos;babel-polyfill&apos;);</span><br><span class="line">require(&apos;./src/app&apos;);</span><br></pre></td></tr></table></figure>
<p>就三行代码 第一行就是跑环境 第二行把垫片垫上 第三行就是去运行我们的主程序入口文件</p>
<h2 id="admin-js"><a href="#admin-js" class="headerlink" title="admin.js"></a>admin.js</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">import &#123; controller, get, logged &#125; from &apos;../../decorators/route&apos;;</span><br><span class="line"></span><br><span class="line">@controller(&apos;/api/v0/user&apos;)</span><br><span class="line">class User &#123;</span><br><span class="line">  @get(&apos;/users&apos;)</span><br><span class="line">  @logged</span><br><span class="line">  async log(ctx, next) &#123;</span><br><span class="line">    console.log(&apos;ola!&apos;);</span><br><span class="line">    await next();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @get(&apos;/users&apos;)</span><br><span class="line">  async allUsers(ctx, next) &#123;</span><br><span class="line">    ctx.body = [&#123; id: 1, name: &apos;a&apos; &#125;, &#123; id: 2, name: &apos;b&apos; &#125;];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>这个就是<code>admin.js</code>想要的效果 自己理一下就好了 重点是怎么去实现这个效果</p>
<h2 id="src-decorators-route-js"><a href="#src-decorators-route-js" class="headerlink" title="/src/decorators/route.js"></a>/src/decorators/route.js</h2><p>这个文件是重点</p>
<p>在admin.js中 我们只是一个简单的类 怎么做处理 才能把它变成一个路由的中间件呢</p>
<p>首先我们把<code>controller</code>实现一下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">const prefix = Symbol(&apos;routerPrefix&apos;);</span><br><span class="line">// ....</span><br><span class="line">export const controller = path =&gt; target =&gt; void (target.prototype[prefix] = path);</span><br></pre></td></tr></table></figure>
<p>她很简单 就是把传入的一个路径 放到类的原型的一个属性上 这个属性呢是一个<code>Symbol</code>值</p>
<p>然后我们去实现<code>get</code>这个装饰器</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">const routeMap = [];</span><br><span class="line"></span><br><span class="line">const toArr = tar =&gt; (tar instanceof Array) ? tar : [tar];</span><br><span class="line">const normalizePath = path =&gt; path.startsWith(&apos;/&apos;) ? path : `/$&#123;path&#125;`;</span><br><span class="line"></span><br><span class="line">const router = config =&gt; (target, key, descriptor) =&gt; &#123;</span><br><span class="line">  routeMap.push(&#123;</span><br><span class="line">    target,</span><br><span class="line">    method: config.method,</span><br><span class="line">    path: normalizePath(config.path),</span><br><span class="line">    cb: toArr(target[key])</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">export const get = path =&gt; router(&#123; method: &apos;get&apos;, path &#125;);</span><br></pre></td></tr></table></figure>
<p>我们把每次调用<code>get</code>装饰器的时候拿到的<code>path</code>以及对应的<code>method</code> 传递给<code>router</code>方法</p>
<p>在<code>router</code>方法中呢 我们往<code>routeMap</code>这个数组去<code>push</code>对象</p>
<p>对象中保留了<code>target</code> 就是我们的实例 里面有我们的路由的命名空间</p>
<p><code>method</code>就是我们http请求的方法</p>
<p><code>path</code>就是调用<code>get</code>装饰器时传递过来的path</p>
<p><code>cb</code> 就是当前装饰的这个方法 我们把它转成数组 为什么转成数组我们等下在讨论</p>
<p>数组里的每一项都有对应的请求方式 请求的路径 请求的时候要执行的方法 那用这些信息注册路由就可以了</p>
<p>然后我们去写一个类 当外部来实例化这个类的时候 我们就完成每个路由的注册</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">export class Route &#123;</span><br><span class="line">  constructor(app, routesDir) &#123;</span><br><span class="line">    this.app = app;</span><br><span class="line">    this.router = new Router();</span><br><span class="line">    this.routesDir = routesDir;</span><br><span class="line"></span><br><span class="line">    this.init();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  init() &#123;</span><br><span class="line">    glob.sync(resolve(this.routesDir, &apos;**/*.js&apos;)).forEach(require);</span><br><span class="line"></span><br><span class="line">    for (let &#123; target, method, path, cb &#125; of routeMap.values()) &#123;</span><br><span class="line">      this.router[method](target[prefix] + path, ...cb);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    this.app.use(this.router.routes());</span><br><span class="line">    this.app.use(this.router.allowedMethods);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首先是构造函数 我们需要一个<code>app(Koa实例)</code> 和路由文件<code>存放的路径</code></p>
<p>然后给自己挂一个<code>Koa-Router</code>实例上去</p>
<p>然后我们调用<code>init</code>方法</p>
<p>先拿到我们<code>/src/router</code>下面的所有js文件 因为这里都是路由相关的文件 然后直接require</p>
<p>完了之后 我们对<code>routeMap</code>的值做一个遍历</p>
<p>然后往路由上面去注册相应的信息 就是通过我们的<code>method</code>和<code>target[prefix] + path</code>确定请求的方法和路径</p>
<p>然后<code>cb</code>我们需要用扩展运算符展开 因为他是一个数组 这里是数组的原因就是一个路由 可以处理多个中间件</p>
<p>然后我们往<code>app</code>上去注册路由中间件</p>
<p>这些完了之后呢 大部分工作就完成了 还差一个<code>logged</code>装饰器</p>
<p>这个装饰器用来判断用户的身份 就是是否登陆</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">export const logged = toMiddleware(async (ctx, next) =&gt; &#123;</span><br><span class="line">  // ...验证session</span><br><span class="line">  await next()</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>这个就是<code>logged</code>方法 很简单 但是有一个问题 我们需要把我们的这个方法 转成一个中间件 不然不知道从哪里去拿<code>上下文</code>和<code>next</code></p>
<p>那么就实现一个<code>toMiddleware</code>方法</p>
<p>这个方法 其实也是很简单</p>
<p>因为他是一个装饰器 所以可以拿到当前的<code>target</code>和<code>key</code></p>
<p>这样就能拿到当前需要装饰的方法</p>
<p>这个方法呢 要进行路由的处理 所以他会变成一个中间件</p>
<p>那么只要把<code>logged</code>和本身的方法同时作为参数 传入到路由的处理中不就可以了吗</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">export const toMiddleware = middleware =&gt; (target, key, descriptor) =&gt; &#123;</span><br><span class="line">  target[key] = [...toArr(middleware), ...toArr(target[key])];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>方法很简单 就是把当前的这个方法 变成一个数组 里面放的就是多个方法 最后把这个数组 在<code>this.router[method](target[prefix] + path, ...cb);</code>这里进行展开 就变成了一个路由多个中间件</p>
<p>现在的整体代码就是</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">import glob from &apos;glob&apos;;</span><br><span class="line">import Router from &apos;koa-router&apos;;</span><br><span class="line">import &#123; resolve &#125; from &apos;path&apos;;</span><br><span class="line"></span><br><span class="line">const prefix = Symbol(&apos;routerPrefix&apos;);</span><br><span class="line">const routeMap = [];</span><br><span class="line"></span><br><span class="line">const toArr = tar =&gt; (tar instanceof Array) ? tar : [tar];</span><br><span class="line"></span><br><span class="line">export class Route &#123;</span><br><span class="line">  constructor(app, routesDir) &#123;</span><br><span class="line">    this.app = app;</span><br><span class="line">    this.router = new Router();</span><br><span class="line">    this.routesDir = routesDir;</span><br><span class="line"></span><br><span class="line">    this.init();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  init() &#123;</span><br><span class="line">    glob.sync(resolve(this.routesDir, &apos;**/*.js&apos;)).forEach(require);</span><br><span class="line"></span><br><span class="line">    for (let &#123; target, method, path, cb &#125; of routeMap.values()) &#123;</span><br><span class="line">      this.router[method](target[prefix] + path, ...cb);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    this.app.use(this.router.routes());</span><br><span class="line">    this.app.use(this.router.allowedMethods);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const normalizePath = path =&gt; path.startsWith(&apos;/&apos;) ? path : `/$&#123;path&#125;`;</span><br><span class="line"></span><br><span class="line">const router = config =&gt; (target, key, descriptor) =&gt; &#123;</span><br><span class="line">  routeMap.push(&#123;</span><br><span class="line">    target,</span><br><span class="line">    method: config.method,</span><br><span class="line">    path: normalizePath(config.path),</span><br><span class="line">    cb: toArr(target[key])</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">export const controller = path =&gt; target =&gt; void (target.prototype[prefix] = path);</span><br><span class="line"></span><br><span class="line">export const get = path =&gt; router(&#123; method: &apos;get&apos;, path &#125;);</span><br><span class="line"></span><br><span class="line">// 将普通函数转成中间件</span><br><span class="line">export const toMiddleware = middleware =&gt; (target, key, descriptor) =&gt; &#123;</span><br><span class="line">  target[key] = [...toArr(middleware), ...toArr(target[key])];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">export const logged = toMiddleware(async (ctx, next) =&gt; &#123;</span><br><span class="line">  // ...验证session</span><br><span class="line">  await next()</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h2 id="src-middlewares-router-js"><a href="#src-middlewares-router-js" class="headerlink" title="/src/middlewares/router.js"></a>/src/middlewares/router.js</h2><p>这个文件就是去拿我们<code>/decorators/route.js</code>中暴露的<code>Route</code>类</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">import &#123; Route &#125; from &apos;../decorators/route&apos;;</span><br><span class="line">import &#123; resolve &#125; from &apos;path&apos;;</span><br><span class="line"></span><br><span class="line">export const router = app =&gt; &#123;</span><br><span class="line">  const dir = resolve(__dirname, &apos;../router&apos;);</span><br><span class="line">  const router = new Route(app, dir);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后把路由文件的根目录和<code>app</code>传递过去就可以了</p>
<h2 id="app-js"><a href="#app-js" class="headerlink" title="app.js"></a>app.js</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">import Koa from &apos;koa&apos;;</span><br><span class="line">import &#123; resolve &#125; from &apos;path&apos;;</span><br><span class="line">import &#123; router &#125; from &apos;./middlewares/router&apos;;</span><br><span class="line"></span><br><span class="line">const app = new Koa();</span><br><span class="line"></span><br><span class="line">router(app);</span><br><span class="line"></span><br><span class="line">app.listen(3000);</span><br></pre></td></tr></table></figure>
<p>这个文件就是入口文件 跑一个服务就好了</p>
<p>这时候就可以<code>node index.js</code></p>
<p>然后在浏览器里看效果了</p>
</div></header></article><!--div.comments#lv-container(data-id = theme.livere_id, data-uid = theme.livere_uid)//script.
  //(function(d, s) {var j, e = d.getElementsByTagName(s)[0];if (typeof LivereTower === 'function') { return; } j = d.createElement(s);j.src = 'https://cdn-city.livere.com/js/embed.dist.js';j.async = true;e.parentNode.insertBefore(j, e);})(document, 'script');--></main><footer class="foot"><div class="foot-copy">&copy; 2017-2018 NISAL</div></footer><script src="/js/scroller.js"></script><script src="/js/main.js"></script><script src="/live2dw/lib/L2Dwidget.min.js?0c58a1486de42ac6cc1c59c7d98ae887"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","model":{"jsonPath":"/live2dw/assets/01/assets/haru01.model.json"}});</script></body></html>