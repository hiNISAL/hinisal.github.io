<!DOCTYPE html><html lang="zh-CN"><head><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1"><meta name="author" content="NISAL"><link rel="alternative" href="/atom.xml" title="HIσ`∀´)σNISAL" type="application/atom+xml"><link rel="icon" href="/favicon.png"><title>Koa2轮子 - HIσ`∀´)σNISAL</title><link rel="stylesheet" href="/css/main.css"><link rel="stylesheet" href="/js/fancybox/jquery.fancybox.min.css"><!--[if lt IE 9]><script>(function(a,b){a="abbr article aside audio bdi canvas data datalist details dialog figcaption figure footer header hgroup main mark meter nav output progress section summary template time video".split(" ");for(b=a.length-1;b>=0;b--)document.createElement(a[b])})()</script><![endif]--><script src="/js/jquery-3.1.1.min.js"></script><script src="/js/fancybox/jquery.fancybox.min.js"></script></head><body style="opacity:0"><header class="head"><h1 class="head-title u-fl"><a href="/">HIσ`∀´)σNISAL</a></h1><nav class="head-nav u-fr"><ul class="head-nav__list"><li class="head-nav__item"><a class="head-nav__link" href="/archives">カタログ/（目录）</a></li></ul></nav></header><main class="main"><article class="post"><header class="post__head"> <time class="post__time" datetime="2018-06-27T01:41:01.000Z">June 27, 2018</time><h1 class="post__title"><a href="/2018/06/27/Koa2轮子/">Koa2轮子</a></h1><div class="post__main echo"><p>Koa是Express团队开发的更轻量小巧 中间件机制更优雅的Web服务的框架</p>
<p>个人认为Koa是一个十分优秀的框架 他的中间件机制可以更好的管理一个请求从入到出的流程</p>
<p>相对于其他框架 Koa的功能可以说少的可怜 从大的来看 只是封装了<code>Request</code>和<code>Response</code> 同时提供了中间件机制 甚至可以说没有太大改动 但是那精巧的设计让整个应用更容易管理和开发</p>
<p>一个框架用久了 总会是想窥探其中的实现方式 在阅读了Koa的源码之后 也想着自己来造一个简单的轮子 实现一下Koa思想</p>
<p>这里造的轮子是十分简单的 总体代码也不过一百来行</p>
<p>步骤很简单</p>
<ul>
<li>封装原生http模块</li>
<li>提供request和response和context对象</li>
<li>封装ctx</li>
<li>提供中间件机制</li>
</ul>
<p>通过这几个步骤 就可以实现一个阉割版本的Koa</p>
<h2 id="目录结构"><a href="#目录结构" class="headerlink" title="目录结构"></a>目录结构</h2><ul>
<li>src<ul>
<li>index.js</li>
<li>response.js</li>
<li>request.js</li>
<li>context.js</li>
<li>compose.js</li>
<li>createContext.js</li>
</ul>
</li>
<li>app.js</li>
</ul>
<h2 id="封装原生http模块"><a href="#封装原生http模块" class="headerlink" title="封装原生http模块"></a>封装原生http模块</h2><blockquote>
<p>index.js</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">const http = require(&apos;http&apos;);</span><br><span class="line">class Application &#123;</span><br><span class="line"></span><br><span class="line">	constructor() &#123;</span><br><span class="line">   	this.cb = () =&gt; &#123;&#125;;</span><br><span class="line">  	&#125;</span><br><span class="line">  </span><br><span class="line">  	use(cb) &#123;</span><br><span class="line">  		this.cb = cb;</span><br><span class="line">  	&#125;</span><br><span class="line">  	</span><br><span class="line">  	listen(...args) &#123;</span><br><span class="line">   	const server = http.createServer((req, res) =&gt; &#123;</span><br><span class="line">	      this.cb(req, res);</span><br><span class="line">	      res.end(&apos;default end&apos;);</span><br><span class="line">    		&#125;).listen(...args);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">module.exports = Application;</span><br></pre></td></tr></table></figure>
<p>这里对原生的<code>http</code>模块进行了简单的封装</p>
<p>应该是很好理解的 通过<code>use</code>方法注册一个回调 在启动服务器后 所有请求都会走这个方法</p>
<p>来尝试着使用一下 引入这个文件</p>
<blockquote>
<p>app.js</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">const Koa = require(&apos;./src&apos;);</span><br><span class="line"></span><br><span class="line">let app = new Koa();</span><br><span class="line"></span><br><span class="line">app.use((req, res) =&gt; &#123;</span><br><span class="line">	res.end(&apos;hello world&apos;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">app.listen(3000);</span><br></pre></td></tr></table></figure>
<p>这时候去浏览器访问 就可以看到<code>hello world</code></p>
<h2 id="提供request和response和context对象"><a href="#提供request和response和context对象" class="headerlink" title="提供request和response和context对象"></a>提供request和response和context对象</h2><p>这三个对象用于生成每个中间件可以拿到的ctx参数</p>
<blockquote>
<p>request.js</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">const request = &#123;</span><br><span class="line">  get url() &#123;</span><br><span class="line">    return this.req.url</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">module.exports = request;</span><br></pre></td></tr></table></figure>
<p>这个文件对外暴露一个对象 通过重写url属性的get方法 来得到http请求的url</p>
<p>这里的this指向最后会是context对象 req是原生的http模块处理路由的时候传递过来的 会被挂载到context对象上</p>
<blockquote>
<p>response.js</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">const response = &#123;</span><br><span class="line">	body: &apos;&apos;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">module.exports = response;</span><br></pre></td></tr></table></figure>
<p>response对象提供了一个body属性 其实就是最终http请求的返回值</p>
<blockquote>
<p>context.js</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">const context = &#123;</span><br><span class="line">  get url() &#123;</span><br><span class="line">    return this.request.url;</span><br><span class="line">  &#125;,</span><br><span class="line">  get body() &#123;</span><br><span class="line">    return this.response.body;</span><br><span class="line">  &#125;,</span><br><span class="line">  set body(val) &#123;</span><br><span class="line">    this.response.body = val;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">module.exports = context;</span><br></pre></td></tr></table></figure>
<p>这里的<code>body</code>指向了<code>this</code>下的<code>response</code> 最后在实例化<code>ctx对象</code>的时候<code>response</code>会被挂到<code>ctx对象</code>中 <code>ctx对象</code>是使用<code>context</code>对象作为原型创建的 所以就有了一个联系的关系</p>
<p>到这里这三个对象都有了 现在可能还不知道具体有什么作用 为什么这么写 为什么这样联系起来 现在还不着急 等构建<code>ctx对象</code>的时候就清楚了</p>
<h2 id="封装ctx"><a href="#封装ctx" class="headerlink" title="封装ctx"></a>封装ctx</h2><p>每一个http请求都需要去封装一个ctx对象 因为请求的信息基本上是不同的</p>
<p>封装ctx在<code>createContext.js</code>文件中进行</p>
<blockquote>
<p>createContext.js</p>
</blockquote>
<p>首先引入<code>request</code>、<code>response</code>、<code>context</code>对象<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">const request = require(&apos;./request&apos;);</span><br><span class="line">const response = require(&apos;./response&apos;);</span><br><span class="line">const context = require(&apos;./context&apos;);</span><br></pre></td></tr></table></figure></p>
<p>把一个函数作为模块导出 这个函数的作用就是生成一个ctx对象<br>这个函数接受两个参数 分别是请求和响应<br>我们要做的其实就是对这两个参数的封装 所以这两个参数必不可少<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">	const request = require(&apos;./request&apos;);</span><br><span class="line">	const response = require(&apos;./response&apos;);</span><br><span class="line">	const context = require(&apos;./context&apos;);</span><br><span class="line"></span><br><span class="line">+	module.exports = (req, res) =&gt; &#123;</span><br><span class="line"></span><br><span class="line">+	&#125;</span><br></pre></td></tr></table></figure></p>
<p>将context对象作为原型 创建ctx基础对象</p>
<p>然后基于request和response对象作为原型 创建新的对象 然后把他们挂到ctx上<br>这个时候 ctx.requrest和ctx.response的this指向就是ctx了<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">	const request = require(&apos;./request&apos;);</span><br><span class="line">	const response = require(&apos;./response&apos;);</span><br><span class="line">	const context = require(&apos;./context&apos;);</span><br><span class="line">	</span><br><span class="line">	module.exports = (req, res) =&gt; &#123;</span><br><span class="line">+	  let ctx = Object.create(context);</span><br><span class="line">	</span><br><span class="line">+	  ctx.request = Object.create(request);</span><br><span class="line">+	  ctx.response = Object.create(response);</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure></p>
<p>接着把req和res两个参数进行挂载 完了之后把生成好的ctx对象返回<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">	const request = require(&apos;./request&apos;);</span><br><span class="line">	const response = require(&apos;./response&apos;);</span><br><span class="line">	const context = require(&apos;./context&apos;);</span><br><span class="line">	</span><br><span class="line">	module.exports = (req, res) =&gt; &#123;</span><br><span class="line">	  let ctx = Object.create(context);</span><br><span class="line">	</span><br><span class="line">	  ctx.request = Object.create(request);</span><br><span class="line">	  ctx.response = Object.create(response);</span><br><span class="line">	</span><br><span class="line">+	  ctx.request.req = req;</span><br><span class="line">+	  ctx.response.res = res;</span><br><span class="line">	</span><br><span class="line">+	  ctx.req = req;</span><br><span class="line">+	  ctx.res = res;</span><br><span class="line">	</span><br><span class="line">+	  return ctx;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure></p>
<p>到这里ctx对象就构建好了再回头体会一下<code>request</code>、<code>response</code>、<code>context</code>对象的实现 就可以明白其中的缘由</p>
<h2 id="提供中间件机制"><a href="#提供中间件机制" class="headerlink" title="提供中间件机制"></a>提供中间件机制</h2><p>中间件机制是核心</p>
<p>中间件使用<code>.use</code>方法注册 最终多个中间件构成一个数组 也可以说是一个列表</p>
<p>要做的其实就是实现通过<code>next</code>方法可以让一个中间件继续往下走 同时也要考虑异步的情况</p>
<p>中间件机制的实现 其实就是串联的执行列表中的函数</p>
<p>比如数组<code>[fn1, fn2, fn3]</code></p>
<p>要现实串联的执行函数 只要便利数组 依次执行即可 同时实现函数之间的返回值的传递</p>
<p>这种方式十分适合同步的情况</p>
<p>但是如果是异步的情况就不太适合去使用循环了</p>
<p>另一种与循环相似的方法就是使用递归</p>
<p>加入我们调用了中间件数组中的第一个中间件 此时这个中间件如果想流转到下一个 就要调用<code>next</code>方法</p>
<p>这样思考 <code>next</code>方法做了什么呢 其实next方法就是调用了当前这个中间件的下一个中间件对吧</p>
<p>同时为了保证异步 <code>next</code>方法返回的必定要是<code>Promise</code> 这样我们就可以使用 <code>async await</code>以同步的方式 来书写异步代码</p>
<blockquote>
<p>compose.js</p>
</blockquote>
<p>关于提供中间件机制的方法 都写在compose.js文件中</p>
<p>首先对外暴露一个方法 这个方法用于处理所有中间件</p>
<p>接受一个参数 参数为中间件组成的数组<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">module.exports = (middlewares) =&gt; &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>然后返回一个函数 这个函数收一个参数 这个参数就是上一步生成好的ctx对象</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">	module.exports = (middlewares) =&gt; &#123;</span><br><span class="line">+	  return ctx =&gt; &#123;</span><br><span class="line">	</span><br><span class="line">+	  &#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<p>然后实现一个<code>patch</code>方法 这个方法用来处理中间件流转的过程</p>
<p>他接受一个参数 这个参数代表中间件在middlewares数组中的位置</p>
<p>所以这里暴露出去的函数返回的也是一个函数</p>
<p>因为需要一个闭包来保留middlewares</p>
<p>在这个函数中 先拿到中间件 然后判断是否存在 如果不存在 则说明没有中间件了</p>
<p>直接返回一个立即执行并决议为成功的Promise</p>
<p>否则呢 就返回一个决议为成功的 则执行这个中间件 并给他传递ctx和next方法</p>
<p>next方法是一个函数 他要做的 就是去执行下一个中间件</p>
<p>所以是<code>patch(i + 1)</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">	module.exports = (middlewares) =&gt; &#123;</span><br><span class="line">	  return ctx =&gt; &#123;</span><br><span class="line">	</span><br><span class="line">+	    function patch(i) &#123;</span><br><span class="line">+	      let fn = middlewares[i];</span><br><span class="line"></span><br><span class="line">+	      if (!fn) &#123;</span><br><span class="line">+	        return Promise.resolve();</span><br><span class="line">+	      &#125;</span><br><span class="line"></span><br><span class="line">+	      return Promise.resolve(fn(ctx, () =&gt; &#123;</span><br><span class="line">+	        return patch(i + 1);</span><br><span class="line">+	      &#125;));</span><br><span class="line">+	    &#125;</span><br><span class="line">	</span><br><span class="line">	  &#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure></p>
<p>另外第一次执行的时候 要默认执行第一个中间件</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">	module.exports = (middlewares) =&gt; &#123;</span><br><span class="line">	  return ctx =&gt; &#123;</span><br><span class="line">	</span><br><span class="line">	    function patch(i) &#123;</span><br><span class="line">	      let fn = middlewares[i];</span><br><span class="line">	</span><br><span class="line">	      if (!fn) &#123;</span><br><span class="line">	        return Promise.resolve();</span><br><span class="line">	      &#125;</span><br><span class="line">	</span><br><span class="line">	      return Promise.resolve(fn(ctx, () =&gt; &#123;</span><br><span class="line">	        return patch(i + 1);</span><br><span class="line">	      &#125;));</span><br><span class="line">	    &#125;</span><br><span class="line">	</span><br><span class="line">+	    return patch(0); </span><br><span class="line">	  &#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<h2 id="修改Application类"><a href="#修改Application类" class="headerlink" title="修改Application类"></a>修改Application类</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">const http = require(&apos;http&apos;);</span><br><span class="line"></span><br><span class="line">const compose = require(&apos;./compose&apos;);</span><br><span class="line">const createCtx = require(&apos;./createContext&apos;);</span><br><span class="line"></span><br><span class="line">class Application &#123;</span><br><span class="line">  constructor() &#123;</span><br><span class="line">    this.middlewares = [];</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  use(cb) &#123;</span><br><span class="line">    this.middlewares.push(cb);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  listen(...args) &#123;</span><br><span class="line">    const server = http.createServer(async (req ,res) =&gt; &#123;</span><br><span class="line">      let ctx = this.createCtx(req, res);</span><br><span class="line"></span><br><span class="line">      const cbs = this.compose(this.middlewares);</span><br><span class="line"></span><br><span class="line">      await cbs(ctx);</span><br><span class="line"></span><br><span class="line">      ctx.res.end(ctx.body);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    server.listen(...args);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  compose(middlewares) &#123;</span><br><span class="line">    return compose(middlewares);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  createCtx(req, res) &#123;</span><br><span class="line">    return createCtx(req, res);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">module.exports = Application;</span><br></pre></td></tr></table></figure>
<p>这里就很好理解了 其实就是把刚才写的都串起来</p>
<p>构造函数中初始化一个数组<code>middlewares</code> 用于保存中间件</p>
<p>同时use方法做的就是往<code>middlewares</code>中添加中间件</p>
<p>如果想链式添加 use方法中可以返回<code>this</code></p>
<p>createCtx和compose方法则是去调用之前写好的这两个方法</p>
<p>最后就是listen</p>
<p><code>createServer</code>时候都回调修改成async 因为之后要使用await来等待异步的执行</p>
<p>然后调用createCtx和compose 完成ctx的创建和中间件流程的构建</p>
<p>完了之后就是执行第一个中间件 之后就可以在中间件中通过next把每一个中间件串起来</p>
<p>到这里一个简单的Koa就完成了</p>
</div></header></article><!--div.comments#lv-container(data-id = theme.livere_id, data-uid = theme.livere_uid)//script.
  //(function(d, s) {var j, e = d.getElementsByTagName(s)[0];if (typeof LivereTower === 'function') { return; } j = d.createElement(s);j.src = 'https://cdn-city.livere.com/js/embed.dist.js';j.async = true;e.parentNode.insertBefore(j, e);})(document, 'script');--></main><footer class="foot"><div class="foot-copy">&copy; 2017-2018 NISAL</div></footer><script src="/js/scroller.js"></script><script src="/js/main.js"></script><script src="/live2dw/lib/L2Dwidget.min.js?0c58a1486de42ac6cc1c59c7d98ae887"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","model":{"jsonPath":"/live2dw/assets/01/assets/haru01.model.json"}});</script></body></html>